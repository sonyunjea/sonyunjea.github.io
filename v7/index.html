<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>딥러닝 핵심 개념 탐색기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: The original document is a linear list of 13 concepts. To improve usability and learning flow, I have designed a thematic structure. The application is divided into four logical groups: '신경망의 기초' (Basics), '퍼셉트론의 발전' (Evolution of Perceptrons), '딥러닝 핵심 요소' (Core Components), and '딥러닝과 CNN' (Deep Learning & CNN). This structure helps users build knowledge progressively. A fixed sidebar navigation allows for quick access to each theme, turning a simple glossary into a structured educational tool. The user can either scroll through the content or jump directly to a topic of interest, interacting with visualizations embedded within each relevant concept. -->
    <!-- Visualization & Content Choices: To make abstract concepts tangible, specific interactive visualizations were chosen. For 'Logic Gates', the goal is to demonstrate linear vs. non-linear separability. A Chart.js scatter plot is used to interactively show that AND/OR are linearly separable while XOR is not, which powerfully justifies the need for multi-layer perceptrons. For 'Activation Functions', the goal is to compare their shapes and outputs. A Chart.js line chart allows users to switch between functions (Sigmoid, Tanh, etc.) to see their characteristics. For complex processes like the 'CNN' workflow or concepts like 'Dropout', diagrams are built using structured HTML and Tailwind CSS for clarity and responsiveness, with simple JS interactions for highlighting. This approach avoids static images and enhances user engagement. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f8f7f4;
            color: #4a4a4a;
        }
        .active-nav {
            background-color: #e3dcd3;
            color: #8c7851;
            font-weight: 700;
        }
        .nav-item {
            transition: all 0.2s ease-in-out;
        }
        .nav-item:hover {
            background-color: #ebe6df;
        }
        .card {
            background-color: #ffffff;
            border: 1px solid #e3dcd3;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.05), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 40vh;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        .btn-toggle {
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .btn-toggle-active {
            background-color: #8c7851 !important;
            color: white !important;
        }
        .diagram-box {
            border: 2px solid #e3dcd3;
            background-color: #fdfcfb;
        }
        .dropout-node {
            transition: opacity 0.3s ease;
        }
        .dropout-node.off {
            opacity: 0.2;
        }
    </style>
</head>
<body class="bg-[#f8f7f4]">
    <div class="flex flex-col md:flex-row min-h-screen">
        <aside class="w-full md:w-64 bg-[#efebe4] border-r border-[#e3dcd3] p-4 md:fixed md:h-screen">
            <h1 class="text-2xl font-bold text-[#8c7851] mb-6">딥러닝 탐색기</h1>
            <nav id="navigation" class="space-y-2">
                <a href="#basics" class="nav-item block px-4 py-2 rounded-md text-gray-700">신경망의 기초</a>
                <a href="#perceptrons" class="nav-item block px-4 py-2 rounded-md text-gray-700">퍼셉트론의 발전</a>
                <a href="#core" class="nav-item block px-4 py-2 rounded-md text-gray-700">딥러닝 핵심 요소</a>
                <a href="#cnn" class="nav-item block px-4 py-2 rounded-md text-gray-700">딥러닝과 CNN</a>
            </nav>
        </aside>

        <main class="flex-1 md:ml-64 p-4 sm:p-6 lg:p-10">
            <header class="mb-10">
                <h2 class="text-4xl font-bold text-gray-800">영상 신호 처리를 위한 딥러닝 핵심 개념</h2>
                <p class="mt-2 text-lg text-gray-600">주요 딥러닝 개념들을 대화형으로 탐색하며 원리를 이해해보세요.</p>
            </header>
            
            <div id="content" class="space-y-16">
            </div>
        </main>
    </div>

    <script>
        const contentData = {
            basics: {
                title: '신경망의 기초',
                description: '신경망이 무엇인지, 어떻게 구성되고 어떤 데이터로 학습하는지에 대한 기본적인 개념들을 알아봅니다.',
                concepts: [
                    {
                        id: 'neural-network',
                        title: '신경망 (Neural Network)',
                        text: "신경망은 인간의 뇌에 있는 신경세포(뉴런)의 연결 구조를 모방하여 만든 인공지능 모델입니다. 수많은 입력 데이터를 받아, 각 데이터의 중요도(가중치)를 계산하고, 그 결과들을 종합하여 최종적인 판단이나 예측을 내리는 방식으로 작동합니다. 입력층, 은닉층, 출력층으로 구성되며, 층이 깊어질수록 더 복잡한 문제를 해결할 수 있습니다."
                    },
                    {
                        id: 'dataset',
                        title: '데이터 셋 (Dataset)',
                        text: "데이터 셋은 특정 목적을 위해 컴퓨터가 학습할 수 있는 형태로 모아놓은 데이터의 집합입니다. 예를 들어, '강아지 이미지 데이터 셋'은 수많은 강아지 사진과 각 사진이 '강아지'라는 정답(레이블) 정보로 구성됩니다. 기계는 이 데이터 셋을 보고 패턴을 학습하여, 나중에 새로운 사진이 주어졌을 때 그것이 강아지인지 아닌지 판단하게 됩니다."
                    },
                    {
                        id: 'neural-circuit',
                        title: '신경회로망 (Neural Circuit Network)',
                        text: "신경회로망은 '신경망(Neural Network)'과 거의 같은 의미로 사용되는 용어입니다. 인간의 뇌가 신경세포들의 복잡한 회로로 이루어져 있다는 점에서 착안하여, 인공적인 신경망 모델을 회로에 비유한 표현입니다."
                    }
                ]
            },
            perceptrons: {
                title: '퍼셉트론의 발전',
                description: '가장 초기 모델인 퍼셉트론부터 다층 퍼셉트론으로 발전하며 어떻게 비선형 문제를 해결하게 되었는지 그 과정을 살펴봅니다.',
                concepts: [
                     {
                        id: 'logic-gates',
                        title: '신경망을 이용한 AND, OR, XOR 논리 게이트',
                        text: "초기 인공지능 모델인 단층 퍼셉트론은 AND와 OR 문제처럼 직선 하나로 결과를 나눌 수 있는 '선형 분리' 문제는 해결할 수 있었지만, XOR 문제처럼 직선 하나로는 나눌 수 없는 문제는 해결하지 못했습니다. 아래 버튼을 눌러 각 논리 게이트의 데이터 분포와 결정 경계(선)를 확인해보세요. XOR 문제를 해결하기 위해 다층 퍼셉트론이 등장하게 되었습니다.",
                        interactive: 'logic-gate-chart'
                    },
                    {
                        id: 'slp-vs-mlp',
                        title: '단층 퍼셉트론 vs 다층 퍼셉트론',
                        text: "<b>단층 퍼셉트론:</b> 입력층과 출력층, 단 두 개의 층으로만 이루어진 가장 단순한 형태의 신경망입니다. 선형적으로 분류 가능한 문제만 해결할 수 있다는 명확한 한계가 있습니다.<br><br><b>다층 퍼셉트론 (MLP):</b> 입력층과 출력층 사이에 하나 이상의 숨겨진 층(은닉층)을 추가한 신경망입니다. 여러 개의 층을 쌓음으로써 XOR 문제와 같이 비선형적인 문제를 해결할 수 있게 되었고, 이것이 딥러닝 발전의 중요한 토대가 되었습니다."
                    },
                    {
                        id: 'perceptron-types',
                        title: '퍼셉트론, 아달라인, 다층 퍼셉트론',
                        text: "<b>퍼셉트론:</b> 가장 초기의 신경망 모델로, 여러 입력을 받아 하나의 결과를 출력합니다. 정답과 예측값이 다를 경우에만 가중치를 업데이트하여 학습합니다.<br><br><b>아달라인 (Adaline):</b> 퍼셉트론을 개선한 모델입니다. 퍼셉트론과 달리, 정답 여부와 상관없이 항상 실제 정답 값과 예측 값의 오차를 계산하고, 그 오차를 줄이는 방향으로 가중치를 업데이트합니다.<br><br><b>다층 퍼셉트론 (MLP):</b> 위에서 설명한 것처럼, 단층 구조의 한계를 극복하기 위해 은닉층을 추가한 모델입니다. 현대 딥러닝 모델의 기본 구조가 됩니다."
                    },
                ]
            },
            core: {
                title: '딥러닝 핵심 요소',
                description: '신경망이 효과적으로 학습하기 위해 필요한 활성화 함수, 학습률, 과적합 방지 기술 등 주요 구성 요소들을 알아봅니다.',
                concepts: [
                    {
                        id: 'activation-function',
                        title: '활성화 함수 (Activation Function)',
                        text: '활성화 함수는 신경망이 계산한 결과를 다음 층으로 어떻게 넘겨줄지 결정하는 함수입니다. 이 함수 덕분에 신경망은 비선형적인 복잡한 문제를 풀 수 있게 됩니다. 아래 버튼을 눌러 대표적인 활성화 함수들의 형태를 확인해보세요.<br><br><b>항등 함수:</b> 입력받은 값을 그대로 출력합니다.<br><b>로지스틱(시그모이드) 함수:</b> 모든 입력 값을 0과 1 사이의 값으로 변환합니다.<br><b>하이퍼볼릭 탄젠트(tanh) 함수:</b> 모든 입력 값을 -1과 1 사이의 값으로 변환합니다.',
                        interactive: 'activation-chart'
                    },
                    {
                        id: 'learning-rate',
                        title: '학습률 (Learning Rate)',
                        text: "학습률은 신경망이 학습 과정에서 틀렸을 때, 정답에 얼마나 '가깝게' 다가갈지를 결정하는 값입니다. 즉, 모델의 가중치를 한 번에 얼마나 업데이트할지를 정하는 보폭(step)의 크기와 같습니다.<br><br><b>학습률이 너무 크면:</b> 정답을 그냥 지나쳐 버려서 학습이 제대로 되지 않고 값이 계속 튈 수 있습니다 (발산).<br><b>학습률이 너무 작으면:</b> 학습 속도가 매우 느려지고, 전체 데이터의 일부 특징에만 과하게 맞춰지는 '지역 최적해'에 빠져 더 좋은 정답을 찾지 못할 수 있습니다.<br><br>따라서 학습률은 모델의 **학습 속도**와 **성능**에 직접적인 인과관계가 있으며, 문제와 데이터에 맞는 적절한 학습률을 찾는 것이 매우 중요합니다."
                    },
                    {
                        id: 'dropout',
                        title: '드롭아웃 (Dropout)',
                        text: "드롭아웃은 신경망의 과적합(Overfitting)을 막기 위한 기술 중 하나입니다. 과적합이란 모델이 학습 데이터는 기가 막히게 잘 맞추지만, 새로운 데이터에 대해서는 성능이 떨어지는 현상을 말합니다. 드롭아웃은 학습 과정에서 신경망의 일부 뉴런(노드)을 무작위로 '끄는' 방식입니다. 이렇게 하면 특정 뉴런에 지나치게 의존하지 않고, 전체적으로 여러 뉴런이 균형 있게 학습하게 되어 모델의 일반화 성능이 향상됩니다.",
                        interactive: 'dropout-diagram'
                    }
                ]
            },
            cnn: {
                title: '딥러닝과 CNN',
                description: '딥러닝의 정의와 특히 영상 처리에 강력한 성능을 보이는 CNN의 구조 및 작동 방식, 그리고 고급 기법인 전이 학습에 대해 알아봅니다.',
                concepts: [
                    {
                        id: 'deep-learning',
                        title: '딥러닝 (Deep Learning)',
                        text: "딥러닝은 다층 퍼셉트론처럼 여러 개의 은닉층을 가진 심층 신경망(Deep Neural Network, DNN)을 사용하여 기계를 학습시키는 방법입니다.<br><br><b>구조:</b> 기본적으로 입력층, 여러 개의 은닉층, 출력층으로 구성됩니다. 특히 영상 처리에서는 CNN(합성곱 신경망) 구조가 널리 쓰입니다.<br><b>방법:</b> 대량의 데이터로부터 기계가 스스로 데이터의 특징(패턴)을 학습하고, 이를 기반으로 분류나 예측 같은 작업을 수행합니다.<br><b>특징 추출기(CNN) 작동 원리:</b> CNN의 '합성곱 층'과 '풀링 층'이 특징 추출기 역할을 합니다. 이미지 위를 필터가 돌아다니면서 기본적인 특징부터 복잡한 형태의 특징까지 점진적으로 추출해냅니다.<br><b>분류기 작동 원리:</b> 특징 추출기에서 뽑아낸 주요 특징 정보를 입력받아, 최종적으로 이 이미지가 어떤 종류에 속하는지 판단하고 분류하는 역할을 합니다."
                    },
                    {
                        id: 'cnn-process',
                        title: 'CNN이 이미지를 인식하는 과정',
                        text: "1. **입력:** 이미지가 픽셀 값들의 행렬(숫자 배열) 형태로 입력됩니다.<br>2. **특징 추출 (Convolution & Pooling):** 필터가 이미지를 훑으며 특징을 뽑아내 '특징 맵'을 만들고(합성곱), 특징 맵의 크기를 줄여 중요한 특징만 남깁니다(풀링). 이 과정을 반복하며 저수준 특징(선, 점)에서 고수준 특징(눈, 코, 입)으로 발전시킵니다.<br>3. **분류 (Fully-Connected Layer):** 추출된 모든 특징들을 1차원 데이터로 평탄화한 후, 완전 연결 계층을 통과시켜 최종적으로 어떤 클래스에 속할 확률이 가장 높은지 계산하여 이미지를 인식합니다."
                    },
                    {
                        id: 'color-image',
                        title: '컬러 이미지를 처리하는 방법',
                        text: "흑백 이미지는 밝기 정보만 가진 1개의 채널(channel)로 이루어져 있지만, 컬러 이미지는 보통 빛의 삼원색인 빨강(Red), 초록(Green), 파랑(Blue)의 정보를 담은 3개의 채널로 구성됩니다. CNN은 이 3개의 채널을 각각 별도의 입력으로 받아들여 특징을 추출한 후, 그 결과들을 종합하여 이미지를 처리합니다. 즉, 3개의 흑백 이미지를 동시에 처리하는 것과 유사한 방식으로 작동합니다."
                    },
                    {
                        id: 'transfer-learning',
                        title: '전이 학습 (Transfer Learning)',
                        text: "전이 학습은 이미 학습된 모델을 가져와서 새로운 문제에 맞게 조정하여 사용하는 방법입니다. 예를 들어, 수백만 장의 이미지로 사물을 구분하도록 훈련된 모델의 특징 파악 능력을 빌려와, 우리가 풀고 싶은 문제에 적용하는 것입니다. 처음부터 모든 것을 학습시키는 대신, 기존의 지식을 활용하므로 더 적은 데이터로도 더 빠르고 효과적으로 학습할 수 있는 장점이 있습니다."
                    }
                ]
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            const contentContainer = document.getElementById('content');
            
            for (const sectionKey in contentData) {
                const sectionData = contentData[sectionKey];
                const sectionEl = document.createElement('section');
                sectionEl.id = sectionKey;
                sectionEl.className = 'scroll-mt-16';

                let conceptsHtml = sectionData.concepts.map(concept => {
                    let interactiveHtml = '';
                    if (concept.interactive === 'logic-gate-chart') {
                        interactiveHtml = `
                            <div class="mt-6 text-center">
                                <div class="inline-flex rounded-md shadow-sm mb-4" role="group">
                                    <button type="button" class="btn-toggle px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-l-lg hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-[#8c7851]" data-gate="AND">AND</button>
                                    <button type="button" class="btn-toggle px-4 py-2 text-sm font-medium text-gray-900 bg-white border-t border-b border-gray-200 hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-[#8c7851]" data-gate="OR">OR</button>
                                    <button type="button" class="btn-toggle px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-r-md hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-[#8c7851]" data-gate="XOR">XOR</button>
                                </div>
                                <div class="chart-container"><canvas id="logicGateChart"></canvas></div>
                            </div>
                        `;
                    } else if (concept.interactive === 'activation-chart') {
                         interactiveHtml = `
                            <div class="mt-6 text-center">
                                <div class="inline-flex rounded-md shadow-sm mb-4" role="group">
                                    <button type="button" class="btn-toggle px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-l-lg hover:bg-gray-100" data-func="sigmoid">Sigmoid</button>
                                    <button type="button" class="btn-toggle px-4 py-2 text-sm font-medium text-gray-900 bg-white border-t border-b border-gray-200 hover:bg-gray-100" data-func="tanh">Tanh</button>
                                    <button type="button" class="btn-toggle px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-r-md hover:bg-gray-100" data-func="identity">Identity</button>
                                </div>
                                <div class="chart-container"><canvas id="activationChart"></canvas></div>
                            </div>
                        `;
                    } else if (concept.interactive === 'dropout-diagram') {
                        interactiveHtml = `
                        <div class="mt-6 p-4 rounded-lg bg-gray-50 border border-gray-200">
                            <div class="flex justify-around items-center mb-4">
                                <div class="text-center">
                                    <p class="font-bold mb-2">신경망 레이어</p>
                                    <div id="dropout-nodes" class="flex gap-4">
                                        ${[...Array(5)].map((_, i) => `<div class="dropout-node w-12 h-12 bg-[#8c7851] rounded-full flex items-center justify-center text-white font-bold text-sm">N${i+1}</div>`).join('')}
                                    </div>
                                </div>
                            </div>
                             <div class="text-center">
                                <button id="dropout-toggle" class="px-4 py-2 bg-[#8c7851] text-white rounded-md hover:bg-[#a18f6c]">드롭아웃 적용/해제</button>
                            </div>
                        </div>
                        `;
                    }

                    return `
                        <div id="${concept.id}" class="card rounded-xl shadow-lg overflow-hidden p-6 md:p-8">
                            <h4 class="text-2xl font-bold text-gray-800">${concept.title}</h4>
                            <p class="mt-4 text-base leading-relaxed">${concept.text}</p>
                            ${interactiveHtml}
                        </div>
                    `;
                }).join('');

                sectionEl.innerHTML = `
                    <h3 class="text-3xl font-bold mb-2 text-gray-800">${sectionData.title}</h3>
                    <p class="text-lg text-gray-600 mb-8 max-w-3xl">${sectionData.description}</p>
                    <div class="space-y-8">${conceptsHtml}</div>
                `;
                contentContainer.appendChild(sectionEl);
            }

            setupInteractiveElements();
            setupNavigation();
        });
        
        function setupInteractiveElements() {
            let logicGateChart, activationChart;

            const logicButtons = document.querySelectorAll('[data-gate]');
            if (logicButtons.length > 0) {
                const ctx = document.getElementById('logicGateChart').getContext('2d');
                const datasets = {
                    AND: {
                        '0': [{x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 0}],
                        '1': [{x: 1, y: 1}]
                    },
                    OR: {
                        '0': [{x: 0, y: 0}],
                        '1': [{x: 0, y: 1}, {x: 1, y: 0}, {x: 1, y: 1}]
                    },
                    XOR: {
                        '0': [{x: 0, y: 0}, {x: 1, y: 1}],
                        '1': [{x: 0, y: 1}, {x: 1, y: 0}]
                    }
                };
                 const lineData = {
                    AND: [{x: -0.5, y: 1.5}, {x: 1.5, y: -0.5}],
                    OR: [{x: -0.5, y: 0.5}, {x: 0.5, y: -0.5}]
                };

                const chartConfig = {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { min: -0.5, max: 1.5, grid: { color: '#eee' } },
                            y: { min: -0.5, max: 1.5, grid: { color: '#eee' } }
                        },
                        plugins: {
                            legend: { display: true },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `([${context.raw.x}, ${context.raw.y}]) -> ${context.dataset.label}`
                                }
                            }
                        }
                    }
                };
                logicGateChart = new Chart(ctx, chartConfig);
                
                function updateLogicGateChart(gate) {
                    logicButtons.forEach(b => b.classList.toggle('btn-toggle-active', b.dataset.gate === gate));
                    const data = datasets[gate];
                    logicGateChart.data.datasets = [
                        { label: 'Output: 0', data: data['0'], backgroundColor: 'rgba(239, 68, 68, 0.7)', pointRadius: 8 },
                        { label: 'Output: 1', data: data['1'], backgroundColor: 'rgba(34, 197, 94, 0.7)', pointRadius: 8 }
                    ];
                    if (lineData[gate]) {
                        logicGateChart.data.datasets.push({
                            type: 'line',
                            label: 'Decision Boundary',
                            data: lineData[gate],
                            borderColor: '#8c7851',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0
                        });
                    }
                    logicGateChart.update();
                }

                logicButtons.forEach(button => button.addEventListener('click', () => updateLogicGateChart(button.dataset.gate)));
                updateLogicGateChart('AND');
            }
            
            const activationButtons = document.querySelectorAll('[data-func]');
            if (activationButtons.length > 0) {
                const ctx = document.getElementById('activationChart').getContext('2d');
                const labels = Array.from({length: 101}, (_, i) => (i - 50) / 10);
                const functions = {
                    sigmoid: x => 1 / (1 + Math.exp(-x)),
                    tanh: x => Math.tanh(x),
                    identity: x => x
                };
                
                const activationChartConfig = {
                    type: 'line',
                    data: { labels: labels, datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { y: { beginAtZero: false, grid: { color: '#eee' } }, x: { grid: { color: '#eee' } } },
                        elements: { point: { radius: 0 } },
                        plugins: { legend: { display: false } }
                    }
                };
                activationChart = new Chart(ctx, activationChartConfig);

                function updateActivationChart(funcName) {
                    activationButtons.forEach(b => b.classList.toggle('btn-toggle-active', b.dataset.func === funcName));
                    const data = labels.map(functions[funcName]);
                    activationChart.data.datasets = [{
                        label: funcName,
                        data: data,
                        borderColor: '#8c7851',
                        borderWidth: 3,
                        tension: 0.1
                    }];
                    activationChart.update();
                }
                
                activationButtons.forEach(button => button.addEventListener('click', () => updateActivationChart(button.dataset.func)));
                updateActivationChart('sigmoid');
            }

            const dropoutToggle = document.getElementById('dropout-toggle');
            if (dropoutToggle) {
                const nodes = document.querySelectorAll('#dropout-nodes .dropout-node');
                let isDropoutActive = false;
                dropoutToggle.addEventListener('click', () => {
                    isDropoutActive = !isDropoutActive;
                    nodes.forEach(node => {
                        if(isDropoutActive) {
                            node.classList.toggle('off', Math.random() > 0.5);
                        } else {
                            node.classList.remove('off');
                        }
                    });
                });
            }
        }
        
        function setupNavigation() {
            const navLinks = document.querySelectorAll('#navigation a');
            const sections = document.querySelectorAll('main section');

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        navLinks.forEach(link => {
                            link.classList.toggle('active-nav', link.getAttribute('href').substring(1) === entry.target.id);
                        });
                    }
                });
            }, { rootMargin: '-50% 0px -50% 0px' });

            sections.forEach(section => observer.observe(section));

            navLinks.forEach(link => {
                link.addEventListener('click', e => {
                    e.preventDefault();
                    document.querySelector(link.getAttribute('href')).scrollIntoView({
                        behavior: 'smooth'
                    });
                });
            });
        }
    </script>
</body>
</html>
